## HDOJ-P2046骨牌铺方格

### 在2×n的一个长方形方格中,用一个1× 2的骨牌铺满方格,输入n ,输出铺放方案的总数.例如n=3时,为2× 3方格，骨牌的铺放方案有三种,如下图：![P2046](P2046.jpg)

很简单我们能很清楚的意识到这是一个递归类型的题目，题目的难点也就推导出递归表达式，首先很容易想到`f(n)`可以的组成一部可以看成`f(n - 1)`再添加一个竖着的骨牌砖块(可以认为这个竖着的砖块就是`f(1)`)，紧接着还有一部分的组成肯定是第`n`处不是竖着的骨牌，这一部分肯定是第`n - 1`和`n`横着的骨牌，这一部分可以看成`f(n - 2)`与`f(2)`去除最后一块是竖着的组合，那接下来我们就要考虑`f(n)`是否可以与`f(n - 3)`与`f(3)`的某一种的组合有关，要找出这种组合，首先其不能具有`f(1)`和`f(2)`参与组合的部分：*即其最后一块不能是竖着的，倒数第一块和倒数第二块不能是两个横着的*，通过例子我们发现`f(3)`参与组合的种类为`0`即由`f(1)`和`f(2)`参与组合的种类能包含`f(3)`，那么他们也必然包含其余的项，再由于参与构成`f(n)`的`f(1)`和`f(2)`中的种类均为`1`那么很容易由递推式`f(n) = f(n - 1) + f(n - 2) (n >= 3)`

## HDOJ-P2047阿牛的EOF牛肉串

### 今年的ACM暑期集训队一共有18人，分为6支队伍。其中有一个叫做EOF的队伍，由04级的阿牛、XC以及05级的COY组成。在共同的集训生活中，大家建立了深厚的友谊，阿牛准备做点什么来纪念这段激情燃烧的岁月，想了一想，阿牛从家里拿来了一块上等的牛肉干，准备在上面刻下一个长度为n的只由"E" "O" "F"三种字符组成的字符串（可以只有其中一种或两种字符，但绝对不能有其他字符）,阿牛同时禁止在串中出现O相邻的情况，他认为，"OO"看起来就像发怒的眼睛，效果不好。你，NEW ACMer,EOF的崇拜者，能帮阿牛算一下一共有多少种满足要求的不同的字符串吗？

这同样是一个递归的问题，但是在我看来要弄明白其递推表达式的话要用两个数组，因为在处理这个问题时第*n - 1*位的是否为*o*是会影响最后一位的情况，所以我准备了三个数组*total*有*n*位所有的满足要求的字符串,*has_o*有*n*位且其为*o*的所有的满足要求的字符串,*no_o*有*n*位且其不为*o*的所有的满足要求的字符串,很明显`total[n] = has_o[n] + no_o[n]`，首先让我们分析*has_o*因为其最简单，`has_o[n] = no_o[n - 1]`第*n*位是*o*的数量和第*n - 1*不是*o*的数量一样，这很容易想到.*no_o[n]*由于其最后一位不是*o*对前一位的数值无要求故其是*total[n - 1]*的2倍即`no_o[n] = 2 * total[n - 1]`。同样的我们对*total*分析，首先利用*total[n] = has_o[n] + no_o[n]*我们代换可得*total[n] = no_o[n - 1] + 2 * total[n - 1]*其中的*no_o[n - 1] = 2 * total[n - 2]*,故得到一个递推式`total[n] = 2 * (total[n - 1] + total[n - 2]) (n >= 3)`这种递推式我们仅仅借助*no_o*和*has_o*而我们在实际的代码中不需要创建的。第二种也是我所采用的做法即 *total[n]* 一定是由 *total[n - 1]* 构成当 *total[n - 1]* 是*o*那么此时第*n*位有两种选择即 *2 * has_o[n - 1] = 2 * no_o[n - 2]* 当 *total[n - 1]* 不是*o*那么此时第*n*位有三种选择即 *3 * no_o[n - 1]* 那么`total[n] = 3 * no_o[n - 1] + 2 * no_o[n - 2] (n >= 3)`在这种思想下就需要实例化*total, no_o, has_o*了并需要在循环中对三者按照推理的公式进行更新。同样的,这两者的递推公式可以相互推导出对方.

## HDOJ-P2048神、上帝以及老天爷 && HDOJ-P2049考新郎

*这两者的题目全部都涉及了同一个数学模型：全排错模型*

### 某人写了n封信，这n封信对应的有n个信封，问把所有的信都装错信封的情况共有多少种？

设错排数位`D[n]`:
- 步骤1：考虑第n封信，把它装入其他信封中的第k个信封中，有n-1种方法
- 步骤2：考虑第k封信，这时有2种情况：
  - 情况1：第k封信装入第n个信封中，那么接着对(除第n封和第k封信外)剩余的n-2封信进行全错排即完成了该事，有 *D(n-2)* 种方法；
  - 情况2：第k封信不装入第n个信封中，那么接着对(除第n封信外)剩余的n-1封信进行全错排即完成了该事，有 *D(n - 1)* 种方法；
- 故：`D[n] = (n - 1) * (D[n - 1] + D[n - 2]) (n >= 3)`

## HDOJ-P2050折线分割平面

### 我们看到过很多直线分割平面的题目，今天的这个题目稍微有些变化，我们要求的是n条折线分割平面的最大数目。比如，一条折线可以将平面分成两部分，两条折线最多可以将平面分成7部分，具体如下所示。![P2050](P2050.jpg)

#### 折线分割模型
- 第*n*条折线的两条射线最多可以与前面的 *2(n-1)* 条射线相交，产生 *2×2(n-1)=4(n-1)* 个交点
- 但这些交点分布在两条射线上，每条射线被分成 *2(n-1)+1* 段
- 两条射线共被分成 *2[2(n-1)+1] = 4n-2* 段
- 然而，转折点处这两段是连接的，需要减去 *1* 个重复计数
- 所以新折线被分成 *(4n-2)-1 = 4n-3* 段
- 每一段都会穿过一个已有区域并将其一分为二，因此新增 *4n-3* 个区域
- `f[n] = f[n - 1] + 4 * n - 3 (n >= 2)`
  
#### 直线分割模型
- 第*n*条直线最多可以与前面的 *n-1* 条直线相交，产生 *n-1* 个交点
- 故这条直线共被分成 *(n - 1) + 1 = n* 段
- 每一段都会穿过一个已有区域并将其一分为二，因此新增 *n* 个区域
- `f[n] = f[n - 1] + n (n >= 2)`